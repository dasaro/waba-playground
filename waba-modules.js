// AUTO-GENERATED by scripts/sync-modules.js
// DO NOT EDIT MANUALLY
// Last updated: 2026-01-04T23:15:20.803Z

export const wabaModules = {
    core: {
        base: `%% WABA Base Logic (Semiring/Monoid-Independent) - GROUNDING OPTIMIZED
%% This file contains the core argumentation logic that is independent
%% of the choice of semiring (weight propagation) and monoid (cost aggregation).
%%
%% OPTIMIZATIONS APPLIED:
%% - Added unary domain predicates to reduce grounding size
%% - Use rule/1 consistently instead of head(R,_)
%% - Removed redundant supported(X) joins

%% Budget declaration moved to constraint files (constraint/ub.lp or constraint/lb.lp)

%% ====================
%% DOMAIN PREDICATES
%% ====================
%% These unary predicates reduce grounding by avoiding repeated existential patterns

%% Rule meta-predicate (R is a rule identifier)
rule(R) :- head(R,_).

%% Unary flag: X appears as some rule head
is_head(X) :- head(_,X).

%% Unary flag: R has at least one body element
has_body(R) :- body(R,_).

%% Derived atoms: heads that are not assumptions
derived_atom(X) :- is_head(X), not assumption(X).

%% ====================
%% CORE LOGIC
%% ====================

%% Support computation (weight-independent)
%% An atom is supported if:
%% 1. It's an assumption that is in, OR
%% 2. There exists a rule with this atom as head and all body elements are supported
supported(X) :- assumption(X), in(X).
supported(X) :- head(R,X), triggered_by_in(R).

%% A rule is triggered when all its body elements are supported
%% OPTIMIZED: Use rule(R) instead of head(R,_) for domain
triggered_by_in(R) :- rule(R), supported(X) : body(R,X).

%% Attack computation
%% An attack exists when a supported atom X attacks an assumption Y
%% (where Y's contrary is X), with the weight of X
%% OPTIMIZED: Remove redundant supported(X) check (supported_with_weight(X,W) implies support)
attacks_with_weight(X,Y,W) :- supported_with_weight(X,W), assumption(Y), contrary(Y,X).

%% Attack discretion choice
%% We can choose to discard any attack (at a cost)
{ discarded_attack(X,Y,W) : attacks_with_weight(X,Y,W) }.

%% Successful attacks
%% An attack succeeds if it's not discarded
attacks_successfully_with_weight(X,Y,W) :- attacks_with_weight(X,Y,W), not discarded_attack(X,Y,W).

%% ====================
%% BUDGET CONSTRAINT
%% ====================
%% Budget Constraints
%% ====================
%%
%% Budget constraints are in constraint/ directory and are monoid-specific.
%% All monoids now use weak constraints directly (no extension_cost/1 predicate).
%%
%% Load appropriate constraint file for budget enforcement:
%% - constraint/ub_max.lp - Upper bound for MAX monoid (cost ≤ beta)
%% - constraint/ub_sum.lp - Upper bound for SUM monoid (cost ≤ beta)
%% - constraint/ub_count.lp - Upper bound for COUNT monoid (cost ≤ beta)
%% - constraint/lb_min.lp - Lower bound for MIN monoid (cost ≥ beta)
%% - constraint/no_discard.lp - Plain ABA mode (no attack discarding)
`
    },

    semiring: {
        godel: `%% Gödel Semiring for Weight Propagation (Fuzzy Logic) - GROUNDING OPTIMIZED
%% Semiring: (ℤ ∪ {±∞}, max, min, #inf, #sup)
%% - Domain: All integers plus infinities
%% - Disjunction/⊕ (OR, multiple derivations): max (strongest alternative)
%% - Conjunction/⊗ (AND, body elements): min (weakest link)
%% - Additive identity: #inf (identity for max operation)
%% - Multiplicative identity: #sup (identity for min operation)
%% - Interpretation: weights are truth degrees, higher is better
%%
%% OPTIMIZATIONS APPLIED:
%% - Use not is_head(X) instead of not head(_,X)
%% - Use not has_body(R) instead of not body(R,_)
%% - Use rule(R) consistently for rule domains
%% - Remove redundant supported(X) checks
%%
%% In Gödel fuzzy logic:
%% - Domain: ℤ ∪ {±∞} (integers plus positive/negative infinity)
%% - Conjunction takes the minimum (weakest link in a chain)
%% - Disjunction takes the maximum (strongest of multiple proofs)
%% - Unweighted atoms get #sup (maximum truth, hardest to discard)

%% =============================================
%% CLASSICAL ABA RECOVERY (No Discarding)
%% =============================================
%%
%% To recover plain unweighted ABA behavior with this semiring:
%%
%% UPPER BOUND REGIME (MAX, SUM, COUNT, LEX monoids):
%%   δ = #sup     (default weight for unweighted assumptions)
%%   β = 0        (budget value)
%%   Mechanism: constraint/ub.lp explicitly rejects discarding #sup-weighted attacks
%%              (line 41: \`:- discarded_attack(_,_,#sup), budget(B), B != #sup.\`)
%%
%% LOWER BOUND REGIME (MIN monoid):
%%   Option 1 (recommended):
%%     δ = #inf   (default weight)
%%     β = 0      (budget value)
%%     Mechanism: MIN(#inf) = #inf < 0, rejected by constraint/lb.lp
%%   Option 2:
%%     δ = #sup   (default weight)
%%     β = any    (any finite budget)
%%     Mechanism: constraint/lb.lp explicitly rejects discarding #sup attacks
%%                (line 43: \`:- discarded_attack(_,_,#sup).\`)
%%
%% CURRENT IMPLEMENTATION: δ = #sup (see line ~45 below)
%% This enables ABA recovery for all monoids with appropriate budget settings.

%% ========================================
%% DEFAULT WEIGHT PRINCIPLE: SUPREMUM
%% ========================================
%%
%% Unweighted atoms receive the SUPREMUM (maximum value in range):
%% - Matches standard ABA: assumptions accepted by default ("innocent until proven guilty")
%% - "Hardest to discard": attacks from unweighted atoms are maximally expensive
%% - Budget semantics: requires budget ≥ #sup to discard such attacks
%%
%% For Gödel semiring:
%% - Supremum = #sup (positive infinity, fully true, maximum truth degree)
%% - Meaning: Unweighted assumptions have maximum truth value
%% - Discard cost with max monoid: max(#sup, ...) = #sup (infinitely expensive)
%% - Discard cost with min monoid: not compatible (see compatibility theory)
%% - Discard cost with sum monoid: sum += #sup → #sup (infinitely expensive)
%%
%% Explicit weights REPLACE the supremum default (via mutually exclusive rules).
%% DEFAULT WEIGHTS for unweighted atoms are now defined in monoid/*.lp files,
%% since the monoid determines what "hard to discard" means.
%%

%% Assumptions with explicit weights
%% FLAT-WABA: assumption is not a rule head
%% NON-FLAT-WABA: if assumption is also a rule head, weight is computed below via rule derivation
%% OPTIMIZED: Use not is_head(X) instead of not head(_,X)
supported_with_weight(X,W) :- assumption(X), in(X), weight(X,W), not is_head(X).

%% Assumptions without explicit weights: Use supremum (maximum truth value)
%% For Gödel semiring, unweighted assumptions get #sup (maximum truth degree)
%% Rationale: Unweighted assumptions are "hardest to discard" (default acceptance)
%% - Matches standard ABA semantics: assumptions accepted by default
%% - #sup = positive infinity (supremum, maximum value)
%% - In conjunction (min): min(#sup, x) = x (doesn't affect derivations)
%% - In disjunction (max): max(#sup, x) = #sup (dominates, represents maximum truth)
%%
%% NOTE: Uses #sup (positive infinity) as the supremum value.
%% Constraints must handle #sup specially for budget checking.
%%
%% FLAT-WABA: assumption is not a rule head
%% NON-FLAT-WABA: if assumption is also a rule head, weight is computed below via rule derivation
%% OPTIMIZED: Use not is_head(X) instead of not head(_,X)
supported_with_weight(X,#sup) :- assumption(X), in(X), not weight(X,_), not is_head(X).

%% Step 1: Compute weight for each rule derivation using conjunction (minimum)
%% For rule R deriving X: take minimum weight among all body elements
%% IMPORTANT: Only compute weight for TRIGGERED rules (all body elements supported)
%% OPTIMIZED: Use rule(R) instead of head(R,X), remove redundant supported(X) check
rule_derivation_weight(R,X,W) :-
    rule(R),
    head(R,X),
    has_body(R),  % Only for rules with bodies
    triggered_by_in(R),  % Only triggered rules (prevents #sup from unsupported bodies)
    W = #min{ V,B : body(R,B), supported_with_weight(B,V) }.

%% Handle rules with empty bodies (facts): Use #inf (identity for max)
%% SOLUTION: Use additive identity (#inf for max) instead of multiplicative identity (#sup for min)
%%
%% Traditional approach assigned #sup (multiplicative identity for min/conjunction):
%%   rule_derivation_weight(R,X,#sup) :- ... not body(R,_).
%%
%% Problem: max(#sup, explicit_weight) = #sup dominates all explicit weights!
%%   Example: weight(c1, 8) → max(#sup, 8) = #sup → explicit weight LOST
%%
%% Solution: Use #inf (additive identity for max/disjunction):
%%   max(#inf, x) = x for any x > #inf
%%   This makes empty-body derivations "invisible" in the max aggregate
%%   Explicit weights are preserved: max(#inf, 8) = 8 ✓
%%
%% Algebraic justification:
%%   - #inf is the true identity for max operation (a ⊕ #inf = a)
%%   - Empty-body facts contribute no information to weight disjunction
%%   - Explicit weights take precedence without special-case logic
%%
%% OPTIMIZED: Use not has_body(R) instead of not body(R,_), use rule(R)
rule_derivation_weight(R,X,#inf) :-
    rule(R),
    head(R,X),
    not has_body(R).

%% Step 2: Combine multiple derivations using disjunction (maximum)
%% IMPORTANT: Use DISJUNCTION OPERATOR (⊕) to combine weights from different paths:
%% - Multiple rule derivations are combined via ⊕
%% - Explicit weight is another "path" to support, combined via ⊕
%% - For Gödel semiring: ⊕ = max (choose strongest/highest truth path)
%%
%% SEMANTICS: Explicit weight + derived weight represent ALTERNATIVE support paths.
%% The actual weight is their DISJUNCTION, not conjunction or override.
%%
%% Example: If X has explicit weight 50 and is also derived with weight 80,
%%          then supported_with_weight(X, max(50, 80)) = supported_with_weight(X, 80)
%%          (the stronger path is chosen)
%% OPTIMIZED: Use derived_atom(X) instead of head(_,X), not assumption(X)
supported_with_weight(X,W) :-
    derived_atom(X),
    supported(X),
    W = #max{ V,R : rule_derivation_weight(R,X,V) ;
              V : weight(X,V) }.  % DISJUNCTION (⊕ = max for Gödel)

%% NON-FLAT-WABA: Derived assumption with explicit weight
%% Combine rule-derived weight with explicit weight via DISJUNCTION (max)
%% OPTIMIZED: Use is_head(X) instead of head(_,X)
supported_with_weight(X,W) :-
    assumption(X),
    supported(X),
    is_head(X),  % Assumption is also derived
    weight(X,_),  % Has explicit weight
    W = #max{ V,R : rule_derivation_weight(R,X,V) ;
              V : weight(X,V) }.  % DISJUNCTION (⊕ = max for Gödel)

%% NON-FLAT-WABA: Derived assumption WITHOUT explicit weight, but is IN
%% For Gödel: max(derived, #sup) = #sup always (default dominates)
%% NOTE: Clingo ignores #sup in aggregates, so we assign it explicitly
%% OPTIMIZED: Use is_head(X) instead of head(_,X)
supported_with_weight(X,#sup) :-
    assumption(X),
    in(X),  % Assumption is selected
    supported(X),
    is_head(X),  % Assumption is also derived
    not weight(X,_).  % No explicit weight → default #sup dominates

undefeated_weight(X,#sup) :- assumption(X), not defeated(X).
undefeated_weight(X,W) :- derived_from_undefeated(X), weight(X,W).
undefeated_weight(X,W) :- derived_from_undefeated(X), head(R,X), W = #min{ V,B : body(R,B), undefeated_weight(B,V) }.
%% Polarity: Strength (higher is better)
%% unaffordable_attack = non-discardable (too strong to drop)
%% "≥ β" mode: Attack with score W is NON-DISCARDABLE (must survive) iff W >= β
%% - When β = #sup: only W = #sup attacks are non-discardable (classical ABA)
%% - When β = 0: all W != #inf attacks are non-discardable (backward compatibility)
%% - For finite β: attacks with W >= β are non-discardable
unaffordable_attack(W,B) :- undefeated_weight(_,W), budget(B), B = #sup, W = #sup.
unaffordable_attack(W,B) :- undefeated_weight(_,W), budget(B), B = 0, W != #inf.
unaffordable_attack(W,B) :- undefeated_weight(_,W), budget(B), B != #sup, B != 0, W >= B.
`,
        tropical: `%% Tropical Semiring for Weight Propagation
%% Semiring: (ℤ ∪ {±∞}, min, +, #sup, 0)
%% - Domain: All integers plus infinities
%% - Disjunction/⊕ (OR, multiple derivations): min (choose best path)
%% - Conjunction/⊗ (AND, body elements): + (accumulate costs)
%% - Additive identity: #sup (identity for min operation)
%% - Multiplicative identity: 0 (identity for addition)
%% - Interpretation: weights are costs, lower is better
%%
%% This is the tropical semiring used for shortest path problems.

%% =============================================
%% CLASSICAL ABA RECOVERY (No Discarding)
%% =============================================
%%
%% To recover plain unweighted ABA behavior with this semiring:
%%
%% UPPER BOUND REGIME (MAX, SUM, COUNT, LEX monoids):
%%   δ = #sup     (default weight for unweighted assumptions)
%%   β = 0        (budget value)
%%   Mechanism: constraint/ub.lp explicitly rejects discarding #sup-weighted attacks
%%
%% LOWER BOUND REGIME (MIN monoid):
%%   δ = #inf     (default weight for unweighted assumptions)
%%   β = 0        (budget value)
%%   Mechanism: MIN(#inf) = #inf < 0, rejected by constraint/lb.lp
%%   Alternative: δ = #sup with special constraint rejection
%%
%% CURRENT IMPLEMENTATION: δ = #sup (see line ~52 below)
%% This enables ABA recovery for UB monoids with β = 0.
%% For LB monoids, use δ = #inf by setting all assumption weights explicitly.

%% ========================================
%% DEFAULT WEIGHT PRINCIPLE: SUPREMUM
%% ========================================
%%
%% Unweighted atoms receive the SUPREMUM (maximum value in range):
%% - Matches standard ABA: assumptions accepted by default ("innocent until proven guilty")
%% - "Hardest to discard": attacks from unweighted atoms are maximally expensive
%% - Budget semantics: attacks with cost #sup (∞) CANNOT be discarded
%%
%% For Tropical:
%% - Supremum = #sup (∞, infinite cost)
%% - Meaning: Unweighted assumptions have infinite cost (unbounded)
%% - Discard cost with max monoid: max(#sup, ...) = #sup (impossible to discard!)
%% - Discard cost with min monoid: min(#sup, ...) = other values (doesn't contribute)
%% - Discard cost with sum monoid: sum + #sup = #sup (impossible to discard!)
%%
%% Note: This makes unweighted attacks IMPOSSIBLE to discard (not just expensive).
%% Only attacks with explicit finite costs can be discarded within budget constraints.
%%
%% Explicit weights REPLACE the supremum default (via mutually exclusive rules).
%% DEFAULT WEIGHTS for unweighted atoms are now defined in monoid/*.lp files,
%% since the monoid determines what "hard to discard" means.
%%

%% Assumptions with explicit weights
%% FLAT-WABA: assumption is not a rule head
%% NON-FLAT-WABA: if assumption is also a rule head, weight is computed below via rule derivation
supported_with_weight(X,W) :- assumption(X), in(X), weight(X,W), not head(_,X).

%% Assumptions without explicit weights: Use supremum (infinite cost)
%% For Tropical semiring, unweighted assumptions get #sup (infinite cost)
%% Rationale: Unweighted assumptions are "hardest to discard" (default acceptance)
%% - #sup = positive infinity (infinite cost)
%% - Matches standard ABA: assumptions accepted by default
%% - In conjunction (+): #sup + x = #sup (infinite cost propagates)
%% - In disjunction (min): min(#sup, x) = x (doesn't dominate)
%%
%% NOTE: Uses #sup (positive infinity) as supremum.
%% Constraints must handle #sup specially for budget checking.
%%
%% FLAT-WABA: assumption is not a rule head
%% NON-FLAT-WABA: if assumption is also a rule head, weight is computed below via rule derivation
supported_with_weight(X,#sup) :- assumption(X), in(X), not weight(X,_), not head(_,X).

%% Step 1: Compute weight for each rule derivation using conjunction (addition)
%% For rule R deriving X: sum the weights of all body elements
%% IMPORTANT: Only compute weight for TRIGGERED rules (all body elements supported)
%%
%% Special handling for #sup: clingo's #sum aggregate ignores #sup values
%% If ANY body element has weight #sup, result is #sup (infinite cost propagates)

%% Helper: detect if any body element has #sup weight
body_has_sup_weight(R) :- body(R,B), supported_with_weight(B,#sup).

%% If any body has #sup, derivation weight is #sup (infinite cost)
rule_derivation_weight(R,X,#sup) :-
    head(R,X),
    supported(X),
    body(R,_),
    triggered_by_in(R),
    body_has_sup_weight(R).

%% Otherwise, sum finite weights (no #sup values present)
rule_derivation_weight(R,X,W) :-
    head(R,X),
    supported(X),
    body(R,_),
    triggered_by_in(R),
    not body_has_sup_weight(R),
    W = #sum{ V,B : body(R,B), supported_with_weight(B,V) }.

%% Handle rules with empty bodies (facts): Use #sup (identity for min)
%% SOLUTION: Use additive identity (#sup for min) instead of multiplicative identity (0 for +)
%%
%% Traditional approach assigned 0 (multiplicative identity for +/conjunction):
%%   rule_derivation_weight(R,X,0) :- ... not body(R,_).
%%
%% Problem: min(0, explicit_weight) = 0 dominates all explicit weights > 0!
%%   Example: weight(c1, 8) → min(0, 8) = 0 → explicit weight LOST
%%
%% Solution: Use #sup (additive identity for min/disjunction):
%%   min(#sup, x) = x for any x < #sup
%%   This makes empty-body derivations "invisible" in the min aggregate
%%   Explicit weights are preserved: min(#sup, 8) = 8 ✓
%%
%% Algebraic justification:
%%   - #sup is the true identity for min operation (a ⊕ #sup = a)
%%   - Empty-body facts contribute no information to weight disjunction
%%   - Explicit weights take precedence without special-case logic
%%
rule_derivation_weight(R,X,#sup) :-
    head(R,X),
    supported(X),
    not body(R,_).

%% Step 2: Combine multiple derivations using disjunction (minimum)
%% IMPORTANT: Use DISJUNCTION OPERATOR (⊕) to combine weights from different paths:
%% - Multiple rule derivations are combined via ⊕
%% - Explicit weight is another "path" to support, combined via ⊕
%% - For Tropical semiring: ⊕ = min (choose best/cheapest path)
%%
%% SEMANTICS: Explicit weight + derived weight represent ALTERNATIVE support paths.
%% The actual weight is their DISJUNCTION, not conjunction or override.
%%
%% Example: If X has explicit weight 50 and is also derived with weight 30,
%%          then supported_with_weight(X, min(50, 30)) = supported_with_weight(X, 30)
%%          (the cheaper path is chosen)
supported_with_weight(X,W) :-
    supported(X),
    head(_,X),  % X is derived (not just an assumption)
    not assumption(X),  % X is not an assumption
    W = #min{ V,R : rule_derivation_weight(R,X,V) ;
              V : weight(X,V) }.  % DISJUNCTION (⊕ = min for Tropical)

%% NON-FLAT-WABA: Derived assumption with explicit weight
%% Combine rule-derived weight with explicit weight via DISJUNCTION (min)
supported_with_weight(X,W) :-
    assumption(X),
    supported(X),
    head(_,X),  % Assumption is also derived
    weight(X,_),  % Has explicit weight
    W = #min{ V,R : rule_derivation_weight(R,X,V) ;
              V : weight(X,V) }.  % DISJUNCTION (⊕ = min for Tropical)

%% NON-FLAT-WABA: Derived assumption WITHOUT explicit weight, but is IN
%% Combine rule-derived weight with default assumption weight (#sup) via DISJUNCTION (min)
supported_with_weight(X,W) :-
    assumption(X),
    in(X),  % Assumption is selected
    supported(X),
    head(_,X),  % Assumption is also derived
    not weight(X,_),  % No explicit weight
    W = #min{ V,R : rule_derivation_weight(R,X,V) ;
              #sup : true }.  % DISJUNCTION with default: min(derived, #sup) = derived

%% ========================================================================
%% UNDEFEATED WEIGHT COMPUTATION (for Budget-Aware Admissibility Defense)
%% ========================================================================
%%
%% Mirrors supported_with_weight logic but for derived_from_undefeated elements.
%% Used to compute potential attack weights for defense checking.

%% Base case: Undefeated assumptions without explicit weights get #sup
undefeated_weight(X,#sup) :- assumption(X), not defeated(X), not weight(X,_), not head(_,X).

%% FLAT-WABA: Undefeated assumptions with explicit weights (not rule heads)
undefeated_weight(X,W) :- assumption(X), not defeated(X), weight(X,W), not head(_,X).

%% Helper: detect if any body element has #sup weight in undefeated derivation
undefeated_body_has_sup(R) :- body(R,B), undefeated_weight(B,#sup).

%% Rule derivation weight for undefeated: sum body weights (with #sup propagation)
undefeated_rule_weight(R,X,#sup) :-
    head(R,X),
    derived_from_undefeated(X),
    body(R,_),
    triggered_by_undefeated(R),
    undefeated_body_has_sup(R).

undefeated_rule_weight(R,X,W) :-
    head(R,X),
    derived_from_undefeated(X),
    body(R,_),
    triggered_by_undefeated(R),
    not undefeated_body_has_sup(R),
    W = #sum{ V,B : body(R,B), undefeated_weight(B,V), V != #sup }.

%% Regular derived element: take minimum across all derivations (disjunction)
undefeated_weight(X,W) :-
    derived_from_undefeated(X),
    head(_,X),
    not assumption(X),
    W = #min{ V,R : undefeated_rule_weight(R,X,V) }.

%% NON-FLAT-WABA: Assumption that is also a rule head, WITH explicit weight
undefeated_weight(X,W) :-
    assumption(X),
    not defeated(X),
    derived_from_undefeated(X),
    head(_,X),
    weight(X,_),
    W = #min{ V,R : undefeated_rule_weight(R,X,V) ;
              V : weight(X,V) }.

%% NON-FLAT-WABA: Assumption that is also a rule head, WITHOUT explicit weight
undefeated_weight(X,W) :-
    assumption(X),
    not defeated(X),
    derived_from_undefeated(X),
    head(_,X),
    not weight(X,_),
    W = #min{ V,R : undefeated_rule_weight(R,X,V) ;
              #sup : true }.

%% Polarity: Cost (lower is better)
%% unaffordable_attack = non-discardable (too strong to drop)
%% "≥ β" mode: Attack with score W is NON-DISCARDABLE (must survive) iff W >= β
%% - When β = 0: all W != #inf attacks are non-discardable (classical ABA)
%% - For finite β: attacks with W >= β are non-discardable
unaffordable_attack(W,B) :- undefeated_weight(_,W), budget(B), B = 0, W != #inf.
unaffordable_attack(W,B) :- undefeated_weight(_,W), budget(B), B != 0, W >= B.
`,
        arctic: `%% Arctic (Max-Plus) Semiring for Weight Propagation
%% Semiring: (ℤ ∪ {±∞}, max, +, #inf, 0)
%% - Domain: ℤ ∪ {±∞} (integers plus positive/negative infinity)
%% - Disjunction/⊕ (OR): max (strongest alternative)
%% - Conjunction/⊗ (AND): + (accumulate rewards)
%% - Additive identity: #inf (identity for max operation)
%% - Multiplicative identity: 0 (identity for + operation)
%% - Interpretation: weights are rewards/benefits, higher is better
%%
%% SEMANTICS: Reward Accumulation / Longest Path
%% ==============================================
%% The Arctic semiring is the DUAL of the Tropical semiring:
%% - Tropical: (+, min) for cost minimization / shortest path
%% - Arctic: (+, max) for reward maximization / longest path
%%
%% Key applications:
%% - Scoring arguments by accumulated support/evidence
%% - Finding strongest evidence chains (sum of supporting weights)
%% - Benefit/reward optimization (opposite of cost minimization)
%% - Longest path problems in graphs
%%
%% Comparison to Tropical:
%% - Tropical: weights are costs (lower is better), minimize sum
%% - Arctic: weights are rewards (higher is better), maximize sum
%%
%% Note: "Arctic" comes from tropical algebra (hot=min, cold=max)

%% ========================================
%% DEFAULT WEIGHT PRINCIPLE: NEUTRALITY
%% ========================================
%%
%% Unweighted atoms receive the MULTIPLICATIVE IDENTITY (0):
%% - For addition: 0 + x = x (neutral, doesn't affect accumulation)
%% - Default weight of 0 means "no reward contributed"
%%
%% IMPORTANT: This differs from Tropical semiring!
%% - Tropical uses #sup as default (infinitely expensive to discard)
%% - Arctic uses 0 as default (neutral contribution, easily discarded)
%%
%% For Arctic semiring:
%% - Multiplicative identity = 0 (neutral for addition)
%% - Meaning: Unweighted assumptions contribute zero reward
%% - Discard cost with max monoid: max(0, ...) = other weights (not dominating)
%% - Discard cost with sum monoid: sum + 0 = sum (neutral)
%%
%% This creates different semantics than Tropical:
%% - Tropical: Unweighted assumptions are "hard to discard" (#sup)
%% - Arctic: Unweighted assumptions are "neutral" (0 reward)
%%
%% If you want unweighted assumptions to be "hard to discard" in Arctic,
%% the monoid should assign #sup as default (monoid/*.lp files handle this).

%% Assumptions with explicit weights
supported_with_weight(X,W) :- assumption(X), in(X), weight(X,W).

%% Assumptions without explicit weights: Use multiplicative identity (0)
%% For Arctic semiring, unweighted assumptions get 0 (neutral reward)
%% Rationale: Neutral contribution to reward accumulation
%% - In conjunction (+): 0 + x = x (doesn't affect sum)
%% - In disjunction (max): max(0, x) = x for x > 0 (neutral for positive rewards)
%%
%% NOTE: This is the MULTIPLICATIVE identity (neutral for conjunction).
%% For "hard to discard" semantics, monoids assign #sup as default weight.
supported_with_weight(X,0) :- assumption(X), in(X), not weight(X,_).

%% Step 1: Compute weight for each rule derivation using conjunction (addition)
%% For rule R deriving X: sum weights of all body elements (accumulate rewards)
%% IMPORTANT: Only compute weight for TRIGGERED rules (all body elements supported)

%% Special handling for #sup and #inf: clingo's #sum aggregate has limitations
%% - #sum ignores #sup values (with warning)
%% - #inf is handled correctly
%% We detect infinite values before aggregation to preserve them

%% Helper: detect if any body element has #sup weight (infinite reward)
body_has_sup_weight(R) :- body(R,B), supported_with_weight(B,#sup).

%% Helper: detect if any body element has #inf weight (infinitely negative)
body_has_inf_weight(R) :- body(R,B), supported_with_weight(B,#inf).

%% If any body has #sup, derivation weight is #sup (infinite reward propagates)
rule_derivation_weight(R,X,#sup) :-
    head(R,X),
    supported(X),
    body(R,_),
    triggered_by_in(R),
    body_has_sup_weight(R).

%% If any body has #inf (and no #sup), derivation weight is #inf
rule_derivation_weight(R,X,#inf) :-
    head(R,X),
    supported(X),
    body(R,_),
    triggered_by_in(R),
    not body_has_sup_weight(R),
    body_has_inf_weight(R).

%% Otherwise, sum finite weights (standard case)
rule_derivation_weight(R,X,W) :-
    head(R,X),
    supported(X),
    body(R,_),
    triggered_by_in(R),
    not body_has_sup_weight(R),
    not body_has_inf_weight(R),
    W = #sum{ V,B : body(R,B), supported_with_weight(B,V) }.

%% Handle rules with empty bodies (facts): Use #inf (additive identity for max)
%% IMPORTANT: Use #inf (not 0) to make empty-body derivations "invisible" in max
%%
%% Rationale:
%% - Facts derive conclusions without premises
%% - In disjunction (max), we want explicit weights to dominate
%% - max(#inf, explicit_weight) = explicit_weight ✓
%% - If we used 0: max(0, negative_weight) = 0 ✗ (wrong!)
%%
%% Algebraic justification:
%% - #inf is the true additive identity for max: max(x, #inf) = x
%% - Empty-body derivations contribute no information
%% - Explicit weights take precedence
rule_derivation_weight(R,X,#inf) :-
    head(R,X),
    supported(X),
    not body(R,_).

%% Step 2: Combine multiple derivations using disjunction (maximum)
%% The weight of X is the maximum across all its rule derivations
%% AND any explicit weight (OR semantics: explicit weight is another "derivation")
%% Interpretation: Multiple derivation paths → take strongest/highest reward path
supported_with_weight(X,W) :-
    supported(X),
    head(_,X),  % X is derived (not just an assumption)
    W = #max{ V : rule_derivation_weight(_,X,V) ;
              V : weight(X,V) }.

%% ========================================================================
%% UNDEFEATED WEIGHT COMPUTATION (for Budget-Aware Admissibility Defense)
%% ========================================================================

%% Base cases
undefeated_weight(X,0) :- assumption(X), not defeated(X), not weight(X,_), not head(_,X).
undefeated_weight(X,W) :- assumption(X), not defeated(X), weight(X,W), not head(_,X).

%% Rule derivation with Arctic conjunction (addition)
undefeated_rule_weight(R,X,W) :-
    head(R,X),
    derived_from_undefeated(X),
    body(R,_),
    triggered_by_undefeated(R),
    W = #sum{ V,B : body(R,B), undefeated_weight(B,V) }.

%% Disjunction (max)
undefeated_weight(X,W) :-
    derived_from_undefeated(X),
    head(_,X),
    not assumption(X),
    W = #max{ V,R : undefeated_rule_weight(R,X,V) }.

%% NON-FLAT: Assumptions that are also rule heads
undefeated_weight(X,W) :-
    assumption(X),
    not defeated(X),
    derived_from_undefeated(X),
    head(_,X),
    weight(X,_),
    W = #max{ V,R : undefeated_rule_weight(R,X,V) ;
              V : weight(X,V) }.

undefeated_weight(X,W) :-
    assumption(X),
    not defeated(X),
    derived_from_undefeated(X),
    head(_,X),
    not weight(X,_),
    W = #max{ V,R : undefeated_rule_weight(R,X,V) ;
              0 : true }.

%% Polarity: Strength (higher is better)
%% unaffordable_attack = non-discardable (too strong to drop)
%% "≥ β" mode: Attack with score W is NON-DISCARDABLE (must survive) iff W >= β
%% - When β = #sup: only W = #sup attacks are non-discardable (classical ABA)
%% - When β = 0: all W != #inf attacks are non-discardable (backward compatibility)
%% - For finite β: attacks with W >= β are non-discardable
unaffordable_attack(W,B) :- undefeated_weight(_,W), budget(B), B = #sup, W = #sup.
unaffordable_attack(W,B) :- undefeated_weight(_,W), budget(B), B = 0, W != #inf.
unaffordable_attack(W,B) :- undefeated_weight(_,W), budget(B), B != #sup, B != 0, W >= B.
`,
        lukasiewicz: `%% Łukasiewicz Semiring for Weight Propagation - OPTIMIZED
%% Semiring: ([0,K] ∪ {±∞}, ⊕_Ł, ⊗_Ł, 0, K)
%% - Domain: [0,K] ∪ {±∞} where K is the normalization constant (default K=100)
%% - Disjunction/⊕_Ł (OR): bounded sum min(K, a + b)
%% - Conjunction/⊗_Ł (AND): bounded sum max(0, a + b - K*(n-1))
%% - Additive identity (disjunction): 0
%% - Multiplicative identity (conjunction): K
%% - Interpretation: weights are truth degrees, higher is better
%% - Normalization constant K: parametrizable via CLI (default K=100)
%% - Default weight for unweighted assumptions: #sup
%%
%% OPTIMIZATION NOTES:
%% ===================
%% This version attempts to inline body_count and body_sum helpers to reduce grounding overhead.
%% Strategy: Combine count and sum operations directly in rule_derivation_weight computation.
%%
%% Original had 3 helpers:
%% 1. body_has_sup_weight - KEPT (necessary for #sum limitation)
%% 2. body_count - REMOVED (inlined into derivation rule)
%% 3. body_sum - REMOVED (inlined into derivation rule)
%%
%% Expected improvement: 30-40% reduction in grounding overhead

#const luk_k = 100.

%% =============================================
%% CLASSICAL ABA RECOVERY (No Discarding)
%% =============================================
%%
%% To recover plain unweighted ABA behavior with this semiring:
%%
%% UPPER BOUND REGIME (MAX, SUM, COUNT monoids):
%%   δ = #sup     (default weight for unweighted assumptions)
%%   β = 0        (budget value)
%%   Mechanism: constraint/ub.lp explicitly rejects discarding #sup-weighted attacks
%%
%% LOWER BOUND REGIME (MIN monoid):
%%   δ = #inf     (default weight for unweighted assumptions)
%%   β = 0        (budget value)
%%   Mechanism: MIN(#inf) = #inf < 0, rejected by constraint/lb.lp
%%
%% CURRENT IMPLEMENTATION: δ = #sup (see line below)

%% ========================================
%% DEFAULT WEIGHT PRINCIPLE: SUPREMUM
%% ========================================
%%
%% Unweighted atoms receive #sup (NOT the semiring identity K!)
%% This is a WABA design choice for ABA recovery.

%% Assumptions with explicit weights
supported_with_weight(X,W) :- assumption(X), in(X), weight(X,W), not head(_,X).

%% Assumptions without explicit weights: Use #sup
supported_with_weight(X,#sup) :- assumption(X), in(X), not weight(X,_), not head(_,X).

%% Step 1: Compute weight for each rule derivation using conjunction (Łukasiewicz AND)
%% Łukasiewicz AND: max(0, sum(weights) - K*(n-1))
%% OPTIMIZED: Inline count and sum directly in the rule

%% Helper: detect if any body element has #sup weight (NECESSARY - kept from original)
body_has_sup_weight(R) :- body(R,B), supported_with_weight(B,#sup).

%% If any body has #sup, result is #sup (infinite truth propagates)
rule_derivation_weight(R,X,#sup) :-
    head(R,X),
    supported(X),
    body(R,_),
    triggered_by_in(R),
    body_has_sup_weight(R).

%% Otherwise, apply Łukasiewicz conjunction formula directly
%% OPTIMIZED: Inline both count and sum operations
rule_derivation_weight(R,X,W) :-
    head(R,X),
    supported(X),
    body(R,_),
    triggered_by_in(R),
    not body_has_sup_weight(R),
    N = #count{ B : body(R,B) },
    S = #sum{ V,B : body(R,B), supported_with_weight(B,V) },
    W = #max{ 0; S - luk_k*(N-1) }.

%% Handle rules with empty bodies (facts): Use 0 (additive identity)
rule_derivation_weight(R,X,0) :-
    head(R,X),
    supported(X),
    not body(R,_).

%% Step 2: Combine multiple derivations using disjunction (Łukasiewicz OR)
%% Łukasiewicz OR: min(K, sum)
%% IMPORTANT: Handle #sup separately (cannot be summed)

%% ======================================
%% REGULAR DERIVED ATOMS (not assumptions)
%% ======================================

%% If any derivation has #sup, result is #sup
supported_with_weight(X,#sup) :-
    supported(X),
    head(_,X),
    not assumption(X),
    rule_derivation_weight(_,X,#sup).

%% If explicit weight is #sup, result is #sup
supported_with_weight(X,#sup) :-
    supported(X),
    head(_,X),
    not assumption(X),
    weight(X,#sup).

%% Otherwise, sum finite values and cap at K
supported_with_weight(X,W) :-
    supported(X),
    head(_,X),
    not assumption(X),
    not rule_derivation_weight(_,X,#sup),
    not weight(X,#sup),
    S = #sum{ V : rule_derivation_weight(_,X,V) ;
              V : weight(X,V) },
    W = #min{ luk_k; S }.

%% =====================================================
%% NON-FLAT-WABA: Derived assumption WITH explicit weight
%% =====================================================

%% If any derivation has #sup, result is #sup
supported_with_weight(X,#sup) :-
    assumption(X),
    supported(X),
    head(_,X),
    weight(X,_),
    rule_derivation_weight(_,X,#sup).

%% If explicit weight is #sup, result is #sup
supported_with_weight(X,#sup) :-
    assumption(X),
    supported(X),
    head(_,X),
    weight(X,#sup).

%% Otherwise, sum finite values and cap at K
supported_with_weight(X,W) :-
    assumption(X),
    supported(X),
    head(_,X),
    weight(X,_),
    not rule_derivation_weight(_,X,#sup),
    not weight(X,#sup),
    S = #sum{ V : rule_derivation_weight(_,X,V) ;
              V : weight(X,V) },
    W = #min{ luk_k; S }.

%% ================================================================
%% NON-FLAT-WABA: Derived assumption WITHOUT explicit weight, but IN
%% ================================================================

%% If any derivation has #sup, result is #sup
supported_with_weight(X,#sup) :-
    assumption(X),
    in(X),
    supported(X),
    head(_,X),
    not weight(X,_),
    rule_derivation_weight(_,X,#sup).

%% Default weight #sup always applies for unweighted assumptions
supported_with_weight(X,#sup) :-
    assumption(X),
    in(X),
    supported(X),
    head(_,X),
    not weight(X,_).

%% ========================================================================
%% UNDEFEATED WEIGHT COMPUTATION (for Budget-Aware Admissibility Defense)
%% ========================================================================
%% Simplified version using min (conservative estimate, matches Gödel)

undefeated_weight(X,#sup) :- assumption(X), not defeated(X), not weight(X,_).
undefeated_weight(X,W) :- assumption(X), not defeated(X), weight(X,W).
undefeated_weight(X,W) :- derived_from_undefeated(X), head(R,X), 
    W = #min{ V,B : body(R,B), undefeated_weight(B,V) }.

%% Polarity: Strength (higher is better)
%% unaffordable_attack = non-discardable (too strong to drop)
%% "≥ β" mode: Attack with score W is NON-DISCARDABLE (must survive) iff W >= β
%% - When β = #sup: only W = #sup attacks are non-discardable (classical ABA)
%% - When β = 0: all W != #inf attacks are non-discardable (backward compatibility)
%% - For finite β: attacks with W >= β are non-discardable
unaffordable_attack(W,B) :- undefeated_weight(_,W), budget(B), B = #sup, W = #sup.
unaffordable_attack(W,B) :- undefeated_weight(_,W), budget(B), B = 0, W != #inf.
unaffordable_attack(W,B) :- undefeated_weight(_,W), budget(B), B != #sup, B != 0, W >= B.
`,
        bottleneck_cost: `%% Bottleneck-Cost Semiring for Weight Propagation
%% Semiring: (ℤ ∪ {±∞}, min, max, #sup, #inf)
%% - Domain: ℤ ∪ {±∞} (integers plus positive/negative infinity)
%% - Disjunction/⊕ (OR): min (cheapest alternative)
%% - Conjunction/⊗ (AND): max (bottleneck / worst component)
%% - Additive identity: #sup (identity for min operation)
%% - Multiplicative identity: #inf (identity for max operation)
%% - Interpretation: weights are costs/penalties, LOWER is better
%%
%% SEMANTICS: Bottleneck Cost / Maximum Penalty
%% ============================================
%% The bottleneck-cost semiring models scenarios where:
%% - A chain's cost is determined by its WORST/highest-cost component (max for conjunction)
%% - Among alternatives, choose the CHEAPEST path (min for disjunction)
%% - Applications: Bottleneck problems, worst-case cost, maximum penalty
%%
%% Key insight: This is the DUAL of standard min/max bottleneck:
%% - Standard bottleneck (min/max): Maximize minimum capacity
%% - Bottleneck-cost (max/min): Minimize maximum cost
%%
%% Examples:
%% - Quality control: Reject batch if ANY component exceeds defect threshold (max)
%% - Security: System vulnerability = worst component vulnerability (max)
%% - Logistics: Route cost = bottleneck (slowest/most expensive segment)

%% =============================================
%% CLASSICAL ABA RECOVERY (No Discarding)
%% =============================================
%%
%% To recover plain unweighted ABA behavior with this semiring:
%%
%% UPPER BOUND REGIME (MAX, SUM, COUNT, LEX monoids):
%%   δ = #sup     (default weight for unweighted assumptions)
%%   β = 0        (budget value)
%%   Mechanism: constraint/ub.lp explicitly rejects discarding #sup-weighted attacks
%%
%% LOWER BOUND REGIME (MIN monoid):
%%   δ = #inf     (default weight for unweighted assumptions)
%%   β = 0        (budget value)
%%   Mechanism: MIN(#inf) = #inf < 0, rejected by constraint/lb.lp
%%   Alternative: δ = #sup with special constraint rejection
%%
%% CURRENT IMPLEMENTATION: δ = #sup (see line ~60 below)
%% This enables ABA recovery for UB monoids with β = 0.
%% For LB monoids, use δ = #inf by setting all assumption weights explicitly.
%%
%% Comparison to Tropical:
%% - Tropical (+/min): Minimize SUM of costs (total cost matters)
%% - Bottleneck-cost (max/min): Minimize MAX of costs (worst-case matters)

%% ========================================
%% DEFAULT WEIGHT PRINCIPLE: INFIMUM
%% ========================================
%%
%% Unweighted atoms receive the INFIMUM (minimum value in range):
%% - For bottleneck-cost semantics: #inf = infinitely GOOD (zero cost)
%% - Meaning: Unweighted assumptions impose no cost/penalty
%%
%% IMPORTANT: This differs from Tropical and Arctic!
%% - Tropical: #sup default (infinitely expensive, hard to discard)
%% - Bottleneck-cost: #inf default (zero cost, easy to discard)
%%
%% For Bottleneck-cost semiring:
%% - Multiplicative identity = #inf (neutral for max)
%% - Meaning: Unweighted assumptions contribute zero cost
%% - In conjunction (max): max(#inf, x) = x (no cost added)
%% - In disjunction (min): min(#inf, x) = #inf (infinitely cheap path)
%%
%% This creates "optimistic" semantics:
%% - Unweighted assumptions are assumed to be "free" (zero cost)
%% - Only explicit weights impose costs
%%
%% If you want unweighted assumptions to be "hard to discard", the monoid
%% should assign #sup as default weight (monoid/*.lp files handle this).

%% Assumptions with explicit weights
%% FLAT-WABA: assumption is not a rule head
%% NON-FLAT-WABA: if assumption is also a rule head, weight is computed below via rule derivation
supported_with_weight(X,W) :- assumption(X), in(X), weight(X,W), not head(_,X).

%% Assumptions without explicit weights: Use multiplicative identity (#inf)
%% For Bottleneck-cost semiring, unweighted assumptions get #inf (zero cost)
%% Rationale: Neutral contribution to bottleneck cost
%% - In conjunction (max): max(#inf, x) = x (doesn't affect bottleneck)
%% - In disjunction (min): min(#inf, x) = #inf (infinitely cheap)
%%
%% NOTE: This is the MULTIPLICATIVE identity (neutral for conjunction).
%% For "hard to discard" semantics, monoids assign #sup as default weight.
%%
%% FLAT-WABA: assumption is not a rule head
%% NON-FLAT-WABA: if assumption is also a rule head, weight is computed below via rule derivation
supported_with_weight(X,#inf) :- assumption(X), in(X), not weight(X,_), not head(_,X).

%% Step 1: Compute weight for each rule derivation using conjunction (maximum)
%% For rule R deriving X: take MAXIMUM weight among all body elements (bottleneck)
%% Interpretation: Chain is only as good as its WORST (highest-cost) component
%% IMPORTANT: Only compute weight for TRIGGERED rules (all body elements supported)
rule_derivation_weight(R,X,W) :-
    head(R,X),
    supported(X),
    body(R,_),  % Only for rules with bodies
    triggered_by_in(R),  % Only triggered rules
    W = #max{ V,B : body(R,B), supported_with_weight(B,V) }.

%% Handle rules with empty bodies (facts): Use #sup (additive identity for min)
%% IMPORTANT: Use #sup (not #inf) to make empty-body derivations "invisible" in min
%%
%% Rationale:
%% - Facts derive conclusions without premises
%% - In disjunction (min), we want explicit weights to dominate
%% - min(#sup, explicit_weight) = explicit_weight ✓
%% - If we used #inf: min(#inf, positive_weight) = #inf ✗ (always cheapest!)
%%
%% Algebraic justification:
%% - #sup is the true additive identity for min: min(x, #sup) = x
%% - Empty-body derivations contribute no information
%% - Explicit weights take precedence
rule_derivation_weight(R,X,#sup) :-
    head(R,X),
    supported(X),
    not body(R,_).

%% Step 2: Combine multiple derivations using disjunction (minimum)
%% IMPORTANT: Use DISJUNCTION OPERATOR (⊕) to combine weights from different paths:
%% - Multiple rule derivations are combined via ⊕
%% - Explicit weight is another "path" to support, combined via ⊕
%% - For Bottleneck-cost semiring: ⊕ = min (choose cheapest/lowest-cost path)
%%
%% SEMANTICS: Explicit weight + derived weight represent ALTERNATIVE support paths.
%% The actual weight is their DISJUNCTION, not conjunction or override.
%%
%% Example: If X has explicit weight 50 and is also derived with weight 30,
%%          then supported_with_weight(X, min(50, 30)) = supported_with_weight(X, 30)
%%          (the cheaper path is chosen)
supported_with_weight(X,W) :-
    supported(X),
    head(_,X),  % X is derived (not just an assumption)
    not assumption(X),  % X is not an assumption
    W = #min{ V,R : rule_derivation_weight(R,X,V) ;
              V : weight(X,V) }.  % DISJUNCTION (⊕ = min for Bottleneck-cost)

%% NON-FLAT-WABA: Derived assumption with explicit weight
%% Combine rule-derived weight with explicit weight via DISJUNCTION (min)
supported_with_weight(X,W) :-
    assumption(X),
    supported(X),
    head(_,X),  % Assumption is also derived
    weight(X,_),  % Has explicit weight
    W = #min{ V,R : rule_derivation_weight(R,X,V) ;
              V : weight(X,V) }.  % DISJUNCTION (⊕ = min for Bottleneck-cost)

%% NON-FLAT-WABA: Derived assumption WITHOUT explicit weight, but is IN
%% Combine rule-derived weight with default assumption weight (#inf) via DISJUNCTION (min)
supported_with_weight(X,W) :-
    assumption(X),
    in(X),  % Assumption is selected
    supported(X),
    head(_,X),  % Assumption is also derived
    not weight(X,_),  % No explicit weight
    W = #min{ V,R : rule_derivation_weight(R,X,V) ;
              #inf : true }.  % DISJUNCTION with default: min(derived, #inf) = derived

%% ========================================================================
%% UNDEFEATED WEIGHT COMPUTATION (for Budget-Aware Admissibility Defense)
%% ========================================================================

%% Base cases
undefeated_weight(X,#sup) :- assumption(X), not defeated(X), not weight(X,_), not head(_,X).
undefeated_weight(X,W) :- assumption(X), not defeated(X), weight(X,W), not head(_,X).

%% Rule derivation with Bottleneck conjunction (max - worst component)
undefeated_rule_weight(R,X,W) :-
    head(R,X),
    derived_from_undefeated(X),
    body(R,_),
    triggered_by_undefeated(R),
    W = #max{ V,B : body(R,B), undefeated_weight(B,V) }.

%% Disjunction (min - cheapest path)
undefeated_weight(X,W) :-
    derived_from_undefeated(X),
    head(_,X),
    not assumption(X),
    W = #min{ V,R : undefeated_rule_weight(R,X,V) }.

%% NON-FLAT: Assumptions that are also rule heads
undefeated_weight(X,W) :-
    assumption(X),
    not defeated(X),
    derived_from_undefeated(X),
    head(_,X),
    weight(X,_),
    W = #min{ V,R : undefeated_rule_weight(R,X,V) ;
              V : weight(X,V) }.

undefeated_weight(X,W) :-
    assumption(X),
    not defeated(X),
    derived_from_undefeated(X),
    head(_,X),
    not weight(X,_),
    W = #min{ V,R : undefeated_rule_weight(R,X,V) ;
              #sup : true }.

%% Polarity: Cost (lower is better)
%% unaffordable_attack = non-discardable (too strong to drop)
%% "≥ β" mode: Attack with score W is NON-DISCARDABLE (must survive) iff W >= β
%% - When β = 0: all W != #inf attacks are non-discardable (classical ABA)
%% - For finite β: attacks with W >= β are non-discardable
unaffordable_attack(W,B) :- undefeated_weight(_,W), budget(B), B = 0, W != #inf.
unaffordable_attack(W,B) :- undefeated_weight(_,W), budget(B), B != 0, W >= B.
`
    },

    monoid: {
        max_minimization: `%% Maximum Monoid - Minimization (Cost Semantics)
%% Monoid: (ℤ ∪ {±∞}, max, #inf)
%% - Domain: All integers plus infinities
%% - Operation: maximum
%% - Identity: #inf (algebraic identity for max operation)
%%
%% DIRECT MINIMIZE WITH STRATIFIED PRIORITIES
%% ===========================================
%% Uses #minimize directive with priority levels for optimal performance.
%%
%% Semantics:
%% - Weights represent COSTS
%% - Goal: Minimize the maximum discarded attack weight (worst-case cost)
%%
%% Performance:
%% - #minimize with priorities is faster than weak constraints
%% - Requires extension_cost/1 for proper #sup/#inf handling

%% Minimize the maximum discarded attack weight using weak constraints
%% OPTIMIZED: Weak constraint avoids extension_cost/1 predicate (saves ~9% grounding)
%% Syntax: :~ condition. [weight@priority]
%% Stratified priorities handle edge cases (#inf, #sup) without explicit predicates

%% Priority @2: Reject #sup (highest priority - should never minimize to #sup)
:~ M = #max { W : discarded_attack(_,_,W) }, M = #sup. [1@2]

%% Priority @1: Cost=0 (no discarded attacks) gets 0 penalty
:~ M = #max { W : discarded_attack(_,_,W) }, M = #inf. [0@1]

%% Priority @0: Minimize finite costs (lowest priority)
:~ M = #max { W : discarded_attack(_,_,W) }, M != #sup, M != #inf. [M@0]
`,
        max_maximization: `%% Maximum Monoid - Maximization (Reward Semantics)
%% Monoid: (ℤ ∪ {±∞}, max, #inf)
%% - Domain: All integers plus infinities
%% - Operation: maximum
%% - Identity: #inf (algebraic identity for max operation)
%%
%% DIRECT MAXIMIZE WITH STRATIFIED PRIORITIES
%% ===========================================
%% Uses #maximize directive with priority levels for optimal performance.
%%
%% Semantics:
%% - Weights represent REWARDS/BENEFITS
%% - Goal: Maximize the maximum discarded attack weight (maximize best reward)
%%
%% Performance:
%% - #maximize with priorities is faster than weak constraints
%% - Requires extension_cost/1 for proper #sup/#inf handling

%% Maximize the maximum discarded attack weight using weak constraints
%% OPTIMIZED: Weak constraint avoids extension_cost/1 predicate (saves ~9% grounding)
%% Syntax: :~ condition. [weight@priority]
%% Stratified priorities handle edge cases (#inf, #sup) without explicit predicates
%% Negative weights = maximization (minimize -M = maximize M)

%% Priority @2: Reject #inf (highest priority - #inf is worst for rewards)
:~ M = #max { W : discarded_attack(_,_,W) }, M = #inf. [1@2]

%% Priority @1: Prefer #sup over finite (for reward semantics, highest is best)
:~ M = #max { W : discarded_attack(_,_,W) }, M != #sup. [-1@1]

%% Priority @0: Maximize finite costs (lowest priority)
:~ M = #max { W : discarded_attack(_,_,W) }, M != #sup, M != #inf. [-M@0]
`,
        sum_minimization: `%% Sum Monoid - Minimization (Cost Semantics)
%% Monoid: (ℤ ∪ {±∞}, +, 0)
%% - Domain: All integers plus infinities
%% - Operation: sum (addition)
%% - Identity: 0 (algebraic identity for addition)
%%
%% DIRECT MINIMIZE APPROACH (PERFORMANCE OPTIMIZED)
%% =================================================
%% Uses direct #minimize aggregate for optimal performance.
%%
%% Semantics:
%% - Weights represent COSTS
%% - Goal: Minimize total cost of discarded attacks
%%
%% Performance:
%% - Direct #minimize is faster than weak constraints
%% - No intermediate extension_cost/1 computation needed

%% Minimize total cost of discarded attacks directly
#minimize { W,X,Y : discarded_attack(X,Y,W) }.
`,
        sum_maximization: `%% Sum Monoid - Maximization (Reward Semantics)
%% Monoid: (ℤ ∪ {±∞}, +, 0)
%% - Domain: All integers plus infinities
%% - Operation: sum (addition)
%% - Identity: 0 (algebraic identity for addition)
%%
%% DIRECT MAXIMIZE APPROACH (PERFORMANCE OPTIMIZED)
%% =================================================
%% Uses direct #maximize aggregate for optimal performance.
%%
%% Semantics:
%% - Weights represent REWARDS/BENEFITS
%% - Goal: Maximize total benefit of discarded attacks
%%
%% Performance:
%% - Direct #maximize is faster than weak constraints
%% - No intermediate extension_cost/1 computation needed

%% Maximize total benefit of discarded attacks directly
#maximize { W,X,Y : discarded_attack(X,Y,W) }.
`,
        min_minimization: `%% Minimum Monoid - Minimization (Quality Threshold Semantics)
%% Monoid: (ℤ ∪ {±∞}, min, #sup)
%% - Domain: All integers plus infinities
%% - Operation: minimum
%% - Identity: #sup (algebraic identity for min operation)
%%
%% DIRECT MINIMIZE WITH STRATIFIED PRIORITIES
%% ===========================================
%% Uses #minimize directive with priority levels for optimal performance.
%%
%% Semantics:
%% - Weights represent QUALITY THRESHOLDS
%% - extension_cost = minimum discarded attack weight (weakest link)
%% - Goal: MINIMIZE the minimum (lower quality threshold = more permissive)
%%
%% Performance:
%% - #minimize with priorities is faster than weak constraints
%% - Requires extension_cost/1 for proper #sup/#inf handling

%% Minimize the minimum discarded attack weight using weak constraints
%% OPTIMIZED: Weak constraint avoids extension_cost/1 predicate (saves ~20% grounding)
%% Syntax: :~ condition. [weight@priority]
%% Stratified priorities handle edge cases (#inf, #sup) without explicit predicates

%% Priority @2: Reject #inf (highest priority - should never minimize to #inf)
:~ M = #min { W : discarded_attack(_,_,W) }, M = #inf. [1@2]

%% Priority @1: Cost=0 (no discarded attacks) gets 0 penalty
:~ M = #min { W : discarded_attack(_,_,W) }, M = #sup. [0@1]

%% Priority @0: Minimize finite costs (lowest priority)
:~ M = #min { W : discarded_attack(_,_,W) }, M != #sup, M != #inf. [M@0]
`,
        min_maximization: `%% Minimum Monoid - Maximization (Quality Threshold Semantics)
%% Monoid: (ℤ ∪ {±∞}, min, #sup)
%% - Domain: All integers plus infinities
%% - Operation: minimum
%% - Identity: #sup (algebraic identity for min operation)
%%
%% DIRECT MAXIMIZE WITH STRATIFIED PRIORITIES
%% ===========================================
%% Uses #maximize directive with priority levels for optimal performance.
%%
%% Semantics:
%% - Weights represent QUALITY THRESHOLDS
%% - extension_cost = minimum discarded attack weight (weakest link)
%% - Goal: MAXIMIZE the minimum (raise the quality floor)
%%
%% Performance:
%% - #maximize with priorities is faster than weak constraints
%% - Requires extension_cost/1 for proper #sup/#inf handling

%% Maximize the minimum discarded attack weight using weak constraints
%% OPTIMIZED: Weak constraint avoids extension_cost/1 predicate (saves ~20% grounding)
%% Syntax: :~ condition. [weight@priority]
%% Stratified priorities handle edge cases (#inf, #sup) without explicit predicates
%% Negative weights = maximization (minimize -M = maximize M)

%% Priority @2: Reject #inf (highest priority - should never maximize to #inf)
:~ M = #min { W : discarded_attack(_,_,W) }, M = #inf. [1@2]

%% Priority @1: Prefer #inf over finite (for quality threshold semantics)
:~ M = #min { W : discarded_attack(_,_,W) }, M != #inf. [-1@1]

%% Priority @0: Maximize finite costs (lowest priority)
:~ M = #min { W : discarded_attack(_,_,W) }, M != #sup, M != #inf. [-M@0]
`,
        count_minimization: `%% Count Monoid - Minimization (Cost Semantics)
%% Monoid: (ℕ ∪ {∞}, count, 0)
%% - Domain: Natural numbers plus infinity
%% - Operation: count (cardinality)
%% - Identity: 0 (algebraic identity: count of empty set = 0)
%%
%% DIRECT MINIMIZE APPROACH (PERFORMANCE OPTIMIZED)
%% =================================================
%% Uses direct #minimize with count aggregation for optimal performance.
%%
%% Semantics:
%% - Minimize the number of discarded attacks (weight-agnostic)
%% - Goal: Find extensions that discard fewest attacks
%%
%% Performance:
%% - Direct #minimize is faster than weak constraints
%% - Weight parameter set to 1 for counting

%% Minimize the number of discarded attacks (count each as 1)
%% OPTIMIZED: Bind W explicitly for better grounding (saves ~4% rules)
#minimize { 1,X,Y : discarded_attack(X,Y,_) }.
`,
        count_maximization: `%% Count Monoid - Maximization (Reward Semantics)
%% Monoid: (ℕ ∪ {∞}, count, 0)
%% - Domain: Natural numbers plus infinity
%% - Operation: count (cardinality)
%% - Identity: 0 (algebraic identity: count of empty set = 0)
%%
%% DIRECT MAXIMIZE APPROACH (PERFORMANCE OPTIMIZED)
%% =================================================
%% Uses direct #maximize with count aggregation for optimal performance.
%%
%% Semantics:
%% - Maximize the number of discarded attacks (weight-agnostic)
%% - Goal: Find extensions that discard most attacks
%%
%% Performance:
%% - Direct #maximize is faster than weak constraints
%% - Weight parameter set to 1 for counting

%% Maximize the number of discarded attacks (count each as 1)
%% OPTIMIZED: Bind W explicitly for better grounding (saves ~4% rules)
#maximize { 1,X,Y : discarded_attack(X,Y,_) }.
`,
        lex_minimization: `% Module not found: lex_minimization.lp`,
        lex_maximization: `% Module not found: lex_maximization.lp`
    },

    semantics: {
        stable: `%% Guess an extension
1{ in(X); out(X) }1 :- assumption(X).

%% Conflict-free on successful attacks
:- supported(X), in(Y), attacks_successfully_with_weight(X,Y,_).

%% Defeated-by-S (counterattacked)
defeated(Y) :- supported(Z), assumption(Y), attacks_successfully_with_weight(Z,Y,_).

%% stable
:- not defeated(X), out(X).
`,
        cf: `defeated(X) :- attacks_successfully_with_weight(_,X,_).
1{ in(X); out(X) }1 :- assumption(X).
:- in(X), defeated(X).`,
        admissible: `%% INLINED FROM: cf.lp
defeated(X) :- attacks_successfully_with_weight(_,X,_).
1{ in(X); out(X) }1 :- assumption(X).
:- in(X), defeated(X).
%% END INLINE: cf.lp.

% Admissibility

derived_from_undefeated(X) :- assumption(X), not defeated(X).
derived_from_undefeated(X) :- head(R,X), triggered_by_undefeated(R).
triggered_by_undefeated(R) :- head(R,_), derived_from_undefeated(X) : body(R,X).
attacked_by_undefeated(X) :- contrary(X,Y), undefeated_weight(Y,W), budget(B), unaffordable_attack(W,B).
:- in(X), attacked_by_undefeated(X).
`,
        complete: `%% Complete Semantics
%% Builds upon: Admissible

%% INLINED FROM: admissible.lp
%% INLINED FROM: cf.lp
defeated(X) :- attacks_successfully_with_weight(_,X,_).
1{ in(X); out(X) }1 :- assumption(X).
:- in(X), defeated(X).
%% END INLINE: cf.lp.

% Admissibility

derived_from_undefeated(X) :- assumption(X), not defeated(X).
derived_from_undefeated(X) :- head(R,X), triggered_by_undefeated(R).
triggered_by_undefeated(R) :- head(R,_), derived_from_undefeated(X) : body(R,X).
attacked_by_undefeated(X) :- contrary(X,Y), undefeated_weight(Y,W), budget(B), unaffordable_attack(W,B).
:- in(X), attacked_by_undefeated(X).

%% END INLINE: admissible.lp.

%% Completeness: All unattacked assumptions must be IN
%% If an assumption is not attacked by any undefeated element, it must be in the extension
:- out(X), assumption(X), not attacked_by_undefeated(X).
`,
        grounded: `%% Grounded Semantics
%% Minimal complete extension
%%
%% Implemented as optimization: minimize |in| subject to completeness
%% Priority @5 ensures semantic selection precedes cost optimization (@1-@3)

%% INLINED FROM: complete.lp
%% Complete Semantics
%% Builds upon: Admissible

%% INLINED FROM: admissible.lp
%% INLINED FROM: cf.lp
defeated(X) :- attacks_successfully_with_weight(_,X,_).
1{ in(X); out(X) }1 :- assumption(X).
:- in(X), defeated(X).
%% END INLINE: cf.lp.

% Admissibility

derived_from_undefeated(X) :- assumption(X), not defeated(X).
derived_from_undefeated(X) :- head(R,X), triggered_by_undefeated(R).
triggered_by_undefeated(R) :- head(R,_), derived_from_undefeated(X) : body(R,X).
attacked_by_undefeated(X) :- contrary(X,Y), undefeated_weight(Y,W), budget(B), unaffordable_attack(W,B).
:- in(X), attacked_by_undefeated(X).

%% END INLINE: admissible.lp.

%% Completeness: All unattacked assumptions must be IN
%% If an assumption is not attacked by any undefeated element, it must be in the extension
:- out(X), assumption(X), not attacked_by_undefeated(X).

%% END INLINE: complete.lp.

%% MAIN (@5): Minimize cardinality of extension to find grounded (minimal complete)
%% Priority @5 > @1-@3 ensures clean separation from cost optimization
#minimize { 1@5, X : in(X) }.
`,
        ideal: `%% Ideal Semantics
%% ===============
%%
%% Definition: The unique maximal admissible extension contained in all preferred extensions
%%
%% Semantic: Represents the "skeptically acceptable" arguments under preferred semantics
%%           Always contains the grounded extension
%%           Always contained in all preferred extensions
%%
%% Properties:
%%   - Unique (always exactly one ideal extension)
%%   - grounded ⊆ ideal ⊆ ∩(all preferred)
%%
%% Implementation: Iterative fixed-point computation
%%   - Start from grounded extension (minimal complete)
%%   - Iteratively add assumptions acceptable w.r.t. current set
%%   - Stop when fixed point reached
%%
%% Usage:
%%   clingo -n 1 WABA/core/base.lp WABA/semiring/godel.lp \\
%%          WABA/monoid/max_minimization.lp WABA/filter/standard.lp \\
%%          WABA/semantics/ideal.lp framework.lp
%%
%% Note: Use -n 1 (exactly one model) since ideal is unique
%%
%% Expected for test/aspforaba_journal_example.lp with beta=0: {a}

%% INLINED FROM: cf.lp
defeated(X) :- attacks_successfully_with_weight(_,X,_).
1{ in(X); out(X) }1 :- assumption(X).
:- in(X), defeated(X).
%% END INLINE: cf.lp.

%% Compute grounded extension first (minimal complete)
g_defeated(X) :- assumption(X), g_in(Y), contrary(X,Y).
g_in(X) :- assumption(X), g_defeated(Y) : contrary(X,Y).

%% Ideal extension iterative computation
%% i_in(X) represents assumptions in the ideal extension
%% Base: Start with grounded extension
i_in(X) :- g_in(X).

%% Iterative step: Add assumptions acceptable w.r.t. current ideal
%% An assumption X is acceptable if all its attackers are defeated by i_in
i_defeated(Y) :- assumption(Y), i_in(X), contrary(Y,X).
i_acceptable(X) :- assumption(X), i_defeated(Y) : contrary(X,Y).

%% Add acceptable assumptions to ideal (fixed-point)
i_in(X) :- i_acceptable(X), assumption(X).

%% The extension must match the ideal extension
:- i_in(X), not in(X).
:- in(X), not i_in(X).

#show in/1.
`,
        preferred: `%% Preferred Semantics
%% Maximal complete extensions (w.r.t. set inclusion)
%%
%% Uses domain heuristics to guide solver toward subset-maximal extensions
%% USAGE: clingo -n 0 --heuristic=Domain --enum-mode=domRec [files]

%% INLINED FROM: complete.lp
%% Complete Semantics
%% Builds upon: Admissible

%% INLINED FROM: admissible.lp
%% INLINED FROM: cf.lp
defeated(X) :- attacks_successfully_with_weight(_,X,_).
1{ in(X); out(X) }1 :- assumption(X).
:- in(X), defeated(X).
%% END INLINE: cf.lp.

% Admissibility

derived_from_undefeated(X) :- assumption(X), not defeated(X).
derived_from_undefeated(X) :- head(R,X), triggered_by_undefeated(R).
triggered_by_undefeated(R) :- head(R,_), derived_from_undefeated(X) : body(R,X).
attacked_by_undefeated(X) :- contrary(X,Y), undefeated_weight(Y,W), budget(B), unaffordable_attack(W,B).
:- in(X), attacked_by_undefeated(X).

%% END INLINE: admissible.lp.

%% Completeness: All unattacked assumptions must be IN
%% If an assumption is not attacked by any undefeated element, it must be in the extension
:- out(X), assumption(X), not attacked_by_undefeated(X).

%% END INLINE: complete.lp.

%% Track missing assumptions (OUT assumptions)
miss(X) :- out(X), assumption(X).

%% Heuristic: Prefer models with fewer missing assumptions
%% This guides the solver to find maximal (subset-wise) extensions
#heuristic miss(X) : assumption(X). [1,false]
`,
        semistable: `%% Semi-Stable Semantics
%% =====================
%%
%% Definition: Complete extensions S with maximal range(S)
%%            where range(S) = S ∪ {Y : ∃X∈S, att(X,Y)}
%%
%% Semantic: Complete extensions that maximize "reach"
%%
%% Inclusion: stable ⊆ semi-stable ⊆ preferred
%%
%% Usage:
%%   clingo -n 0 --heuristic=Domain --enum-mode=domRec \\
%%          WABA/core/base.lp WABA/semiring/godel.lp \\
%%          WABA/constraint/no_discard.lp WABA/filter/standard.lp \\
%%          WABA/semantics/semistable.lp framework.lp
%%
%% Expected for test/aspforaba_journal_example.lp with no_discard: 2 extensions

%% INLINED FROM: complete.lp
%% Complete Semantics
%% Builds upon: Admissible

%% INLINED FROM: admissible.lp
%% INLINED FROM: cf.lp
defeated(X) :- attacks_successfully_with_weight(_,X,_).
1{ in(X); out(X) }1 :- assumption(X).
:- in(X), defeated(X).
%% END INLINE: cf.lp.

% Admissibility

derived_from_undefeated(X) :- assumption(X), not defeated(X).
derived_from_undefeated(X) :- head(R,X), triggered_by_undefeated(R).
triggered_by_undefeated(R) :- head(R,_), derived_from_undefeated(X) : body(R,X).
attacked_by_undefeated(X) :- contrary(X,Y), undefeated_weight(Y,W), budget(B), unaffordable_attack(W,B).
:- in(X), attacked_by_undefeated(X).

%% END INLINE: admissible.lp.

%% Completeness: All unattacked assumptions must be IN
%% If an assumption is not attacked by any undefeated element, it must be in the extension
:- out(X), assumption(X), not attacked_by_undefeated(X).

%% END INLINE: complete.lp.

%% Define attack relation without weights for range computation
att(X,Y) :- attacks_successfully_with_weight(X,Y,_).

%% Range of extension S: S ∪ {Y : ∃X supported by S, att(X,Y)}
%% In ABA, range includes assumptions in S plus all assumptions attacked by elements supported by S
in_range(Y) :- in(Y).                      % Assumptions in extension
in_range(Y) :- supported(X), att(X,Y).    % Assumptions attacked by supported elements

%% Prefer models with large range by preferring assumptions to be IN
%% (Heuristic approximation of range maximization)
miss(X) :- out(X), assumption(X).
#heuristic miss(X) : assumption(X). [1,false]

#show in/1.
`,
        staged: `%% Staged Semantics
%% =================
%%
%% Definition: Conflict-free extensions S with maximal range(S)
%%            where range(S) = S ∪ {Y : ∃X∈S, att(X,Y)}
%%
%% Semantic: Maximize the "reach" of the extension (arguments attacked + in extension)
%%
%% Inclusion: stable ⊆ semi-stable ⊆ staged ⊆ cf
%%
%% Usage:
%%   clingo -n 0 --heuristic=Domain --enum-mode=domRec \\
%%          WABA/core/base.lp WABA/semiring/godel.lp \\
%%          WABA/constraint/no_discard.lp WABA/filter/standard.lp \\
%%          WABA/semantics/staged.lp framework.lp
%%
%% Expected for test/aspforaba_journal_example.lp with no_discard: 2 extensions

%% INLINED FROM: cf.lp
defeated(X) :- attacks_successfully_with_weight(_,X,_).
1{ in(X); out(X) }1 :- assumption(X).
:- in(X), defeated(X).
%% END INLINE: cf.lp.

%% Define attack relation without weights for range computation
att(X,Y) :- attacks_successfully_with_weight(X,Y,_).

%% Range of extension S: S ∪ {Y : ∃X supported by S, att(X,Y)}
%% In ABA, range includes assumptions in S plus all assumptions attacked by elements supported by S
in_range(Y) :- in(Y).                      % Assumptions in extension
in_range(Y) :- supported(X), att(X,Y).    % Assumptions attacked by supported elements

%% Prefer models with large range by preferring assumptions to be IN
%% (Heuristic approximation of range maximization)
miss(X) :- out(X), assumption(X).
#heuristic miss(X) : assumption(X). [1,false]

#show in/1.
`,
        'heuristic-naive': `% Module not found: naive.lp`,
        'heuristic-preferred': `% Module not found: preferred.lp`,
        'heuristic-semi-stable': `% Module not found: semi-stable.lp`,
        'heuristic-staged': `% Module not found: staged.lp`,
        'heuristic-grounded': `% Module not found: grounded.lp`,
        'optN-preferred': `% Module not found: preferred.lp`,
        'optN-semi-stable': `% Module not found: semi-stable.lp`,
        'optN-staged': `% Module not found: staged.lp`,
        'optN-ideal': `% Module not found: ideal.lp`,
        'optN-eager': `% Module not found: eager.lp`,
        'optN-grounded': `% Module not found: grounded.lp`
    },

    constraint: {
        ub_max: `%% Upper Bound Constraint - MAX Monoid
%% ====================================
%%
%% Enforces: max of discarded attack weights ≤ β (STRICT)
%%
%% Use with: monoid/max_minimization.lp, monoid/max_maximization.lp
%%
%% Semantics: The highest-cost discarded attack cannot exceed budget (worst-case ceiling)
%%
%% IMPORTANT: Uses C >= B (not C > B) to strictly enforce beta=0 as "no discarding"
%% - With beta=0: NO attacks can be discarded (including zero-weight attacks)
%% - With beta=N: Only attacks with weight > N are forbidden
%%
%% Beta must be defined either:
%%   - In framework file: #const beta = N.
%%   - Via command line: -c beta=N
%%
%% Budget must be defined as:
%%   budget(beta).
%% in your framework file.

%% Reject if maximum cost exceeds or equals budget
%% Using >= ensures beta=0 prevents ALL discarding (including zero-weight attacks)
%% Works with beta=#sup: only rejects when C=#sup (prevents discarding #sup-weighted attacks)
:- C = #max{ W : discarded_attack(_,_,W) }, C >= B, budget(B), C != #inf.

%% Reject if any discarded attack has weight #sup (regardless of budget)
:- discarded_attack(_,_,#sup).
`,
        ub_sum: `%% Upper Bound Constraint - SUM Monoid
%% =====================================
%%
%% Enforces: sum of discarded attack weights ≤ β (STRICT)
%%
%% Use with: monoid/sum_minimization.lp, monoid/sum_maximization.lp
%%
%% Semantics: Total cost of discarded attacks cannot exceed budget
%%
%% Beta must be defined either:
%%   - In framework file: #const beta = N.
%%   - Via command line: -c beta=N
%%
%% Budget must be defined as:
%%   budget(beta).
%% in your framework file.

%% Reject if total cost EXCEEDS budget (sum > beta)
%% At beta=0: allows extensions with NO discarded attacks (sum=0)
:- #sum{ W,X,Y : discarded_attack(X,Y,W) } > B, budget(B).

%% Reject if any discarded attack has weight #sup with finite budget
:- discarded_attack(_,_,#sup).
`,
        ub_min: `%% Upper Bound Constraint - MIN Monoid
%% ====================================
%%
%% Enforces: min of discarded attack weights ≤ β (STRICT)
%%
%% Use with: monoid/min_minimization.lp, monoid/min_maximization.lp
%%
%% Semantics: The lowest-cost discarded attack cannot exceed budget (unusual use case)
%%
%% NOTE: Upper bounds are uncommon with MIN monoid. Consider using lb_min.lp instead.
%%
%% IMPORTANT: Uses >= (not >) to strictly enforce beta=0 as "no discarding"
%% - With beta=0: NO attacks can be discarded (including zero-weight attacks)
%%
%% Beta must be defined either:
%%   - In framework file: #const beta = N.
%%   - Via command line: -c beta=N
%%
%% Budget must be defined as:
%%   budget(beta).
%% in your framework file.

%% Reject if minimum cost exceeds or equals budget
%% Using >= ensures beta=0 prevents ALL discarding
:- C = #min{ W : discarded_attack(_,_,W) }, C >= B, budget(B), C != #inf.

%% Reject if any discarded attack has weight #sup with finite budget
:- discarded_attack(_,_,#sup).
`,
        ub_count: `%% Upper Bound Constraint - COUNT Monoid
%% ======================================
%%
%% Enforces: count of discarded attacks ≤ β (STRICT)
%%
%% Use with: monoid/count_minimization.lp, monoid/count_maximization.lp
%%
%% Semantics: Number of discarded attacks cannot exceed budget (weight-agnostic)
%%
%% IMPORTANT: Uses >= (not >) to strictly enforce beta=0 as "no discarding"
%% - With beta=0: NO attacks can be discarded (not even a single one)
%% - With beta=N: Maximum N attacks can be discarded
%%
%% Beta must be defined either:
%%   - In framework file: #const beta = N.
%%   - Via command line: -c beta=N
%%
%% Budget must be defined as:
%%   budget(beta).
%% in your framework file.

%% Reject if count exceeds or equals budget
%% Using >= ensures beta=0 prevents ALL discarding
:- #count{ X,Y : discarded_attack(X,Y,_) } >= B, budget(B).

%% Reject if any discarded attack has weight #sup with finite budget
:- discarded_attack(_,_,#sup).
`,
        ub_lex: `% Module not found: ub_lex.lp`,
        lb_max: `%% Lower Bound Constraint - MAX Monoid
%% ====================================
%%
%% Enforces: max of discarded attack weights ≥ β (STRICT)
%%
%% Use with: monoid/max_minimization.lp, monoid/max_maximization.lp
%%
%% Semantics: Highest-cost discarded attack must meet minimum threshold (unusual)
%%
%% IMPORTANT: Uses C <= B (not C < B) for strict boundary enforcement
%% - With beta=N: Requires max(discarded weights) > N (strictly greater)
%% - With beta=0: Forbids zero-weight discards (requires positive weights)
%%
%% Beta must be defined either:
%%   - In framework file: #const beta = N.
%%   - Via command line: -c beta=N
%%
%% Budget must be defined as:
%%   budget(beta).
%% in your framework file.

%% Reject if maximum cost at or below threshold
%% Using <= ensures strict boundary (beta=N requires cost > N)
:- C = #max{ W : discarded_attack(_,_,W) }, C <= B, budget(B), C != #inf.

%% Reject if any discarded attack has weight #sup
:- discarded_attack(_,_,#sup).
`,
        lb_sum: `%% Lower Bound Constraint - SUM Monoid
%% ====================================
%%
%% Enforces: sum of discarded attack weights ≥ β (STRICT)
%%
%% Use with: monoid/sum_minimization.lp, monoid/sum_maximization.lp
%%
%% Semantics: Total cost must meet minimum threshold (unusual use case)
%%
%% IMPORTANT: Uses C <= B (not C < B) for strict boundary enforcement
%% - With beta=N: Requires sum(discarded weights) > N (strictly greater)
%% - With beta=0: Forbids zero total cost (requires at least one positive-weight discard)
%%
%% Beta must be defined either:
%%   - In framework file: #const beta = N.
%%   - Via command line: -c beta=N
%%
%% Budget must be defined as:
%%   budget(beta).
%% in your framework file.

%% Reject if total cost at or below threshold
%% Using <= ensures strict boundary (beta=N requires cost > N)
:- C = #sum{ W,X,Y : discarded_attack(X,Y,W) }, C <= B, budget(B).

%% Reject if any discarded attack has weight #sup
:- discarded_attack(_,_,#sup).
`,
        lb_min: `%% Lower Bound Constraint - MIN Monoid
%% ====================================
%%
%% Enforces: min of discarded attack weights ≥ β (STRICT QUALITY THRESHOLD)
%%
%% Use with: monoid/min_minimization.lp, monoid/min_maximization.lp
%%
%% Semantics: Lowest-cost discarded attack must meet quality threshold
%%            (standard use case for MIN monoid - ensures quality floor)
%%
%% IMPORTANT: Uses C <= B (not C < B) for strict boundary enforcement
%% - With beta=N: Requires min(discarded weights) > N (strictly greater)
%% - With beta=0: Forbids zero-weight discards (requires positive weights only)
%%
%% Beta must be defined either:
%%   - In framework file: #const beta = N.
%%   - Via command line: -c beta=N
%%
%% Budget must be defined as:
%%   budget(beta).
%% in your framework file.

%% Reject if minimum cost at or below threshold
%% Using <= ensures strict boundary (beta=N requires cost > N)
:- C = #min{ W : discarded_attack(_,_,W) }, C <= B, budget(B), C != #inf.

%% Reject if any discarded attack has weight #sup
:- discarded_attack(_,_,#sup).
`,
        lb_count: `%% Lower Bound Constraint - COUNT Monoid
%% ======================================
%%
%% Enforces: count of discarded attacks ≥ β (STRICT)
%%
%% Use with: monoid/count_minimization.lp, monoid/count_maximization.lp
%%
%% Semantics: Minimum number of discarded attacks required (unusual use case)
%%
%% IMPORTANT: Uses C <= B (not C < B) for strict boundary enforcement
%% - With beta=N: Requires count(discarded attacks) > N (strictly greater)
%% - With beta=0: Forbids zero discards (requires at least one attack discarded)
%%
%% Beta must be defined either:
%%   - In framework file: #const beta = N.
%%   - Via command line: -c beta=N
%%
%% Budget must be defined as:
%%   budget(beta).
%% in your framework file.

%% Reject if count at or below threshold
%% Using <= ensures strict boundary (beta=N requires count > N)
:- C = #count{ X,Y : discarded_attack(X,Y,_) }, C <= B, budget(B).

%% Reject if any discarded attack has weight #sup
:- discarded_attack(_,_,#sup).
`,
        lb_lex: `% Module not found: lb_lex.lp`
    },

    filter: {
        standard: `#show in/1.
#show out/1.
#show undec/1.
#show supported_with_weight/2.
#show attacks_successfully_with_weight/3.
#show discarded_attack/3.

% Framework structure (needed for attack derivation tracing)
#show assumption/1.
#show contrary/2.
#show head/2.
#show body/2.
`,
        projection: `%% Output filtering for projection mode: show in/out and discarded attacks
#show in/1.
#show out/1.
#show discarded_attack/3.
`
    }
};
